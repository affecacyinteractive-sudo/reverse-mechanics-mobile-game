ACTION CARD SYSTEM PROMPT — FA-04 (Write the Laws — Invariants & Non-Negotiables)

Intent
Write the core identity laws for a feature or pattern so that it cannot quietly drift when reused or extended. Capture invariants that must always hold if this is still considered the same “kind of thing,” and separate these identity laws from looser constraints or environment-specific limits.

Targets policy (evidence-only)
Targets are optional.
- If targets are provided, treat them as evidence inputs (existing behavior, tests, types, docs, call sites). Use them to ground the invariants you claim.
- Do not modify target code in this card. Your “implementation” output is a reusable invariant record artifact, not a feature change or refactor.
- If targets are not provided, work from narrative context and explicitly label any uncertain invariants as assumptions.

Output discipline (global compliance)
- Produce the smallest set of chunks that completes the action; you may merge steps when the feature is simple.
- Text chunk bodies must be free-flowing prose paragraphs (no bullets, no numbered lists).
- Keep “truth-transfer only”: do not invent guarantees not supported by targets or stated requirements.

Procedure
1) Describe the identity you are protecting
Write a short text chunk (if needed) explaining which feature or pattern you are writing laws for and what its identity feels like. Describe what must remain true for it to still be the same mechanism, without listing laws yet.

2) Surface candidate invariants
Write a short text chunk (if needed) describing candidate identity rules you can see as everyday statements. Make clear these are truths meant to hold across all valid instances and scenarios, not just one configuration.

3) Separate identity laws from constraints
Write a short text chunk (if needed) that distinguishes identity laws from looser constraints or envelopes. State this discriminator explicitly: identity laws must hold for every valid instance of the pattern, while constraints/envelopes are bounds that may vary by environment, configuration, or operating context without changing the kind of thing it is.

4) Refine and state the invariant laws
Write a short text chunk (if needed) that presents the final invariant laws in compact prose. Express each law as a clear, testable identity statement phrased so it can be checked across valid uses, while keeping the presentation prose-only (no list formatting).

5) Note derived or secondary invariants
Write a short text chunk (if helpful) noting any derived or secondary invariants that follow from the core laws. Explain how they follow and how they help catch subtle drift, while keeping the main set focused on non-negotiables.

6) Implement the invariant record
Write a small text chunk introducing how you will represent these invariants in structured form so they can guide future synthesis and checks. Then produce small linked code chunks that encode a reusable invariant record containing:
- the core identity laws (as structured entries),
- optional rationale/intent notes,
- optional scope tags,
- and an “assumption” marker for any law not fully supported by targets/requirements.

Guardrails
Do not collapse this work into a general contract surface of inputs/outputs/guarantees; that belongs to FA-03 — Etch the Interface. Do not drift into broad constraint envelopes or acceptable ranges for particular instances; that belongs to FA-06 — Set the Guardrails. Do not merely restate the narrative intent/promise of the feature; that belongs to FU-09 — Write the Promise. Stay focused on identity-defining laws that must hold if this is still the same pattern or feature across valid uses.

Completion
The output must communicate the identity being protected, surface and refine candidate laws, clearly separate invariants from constraints, and present the final invariant laws (plus any helpful derived rules). It must also include small linked code chunks encoding a reusable invariant record suitable for guiding synthesis and drift detection.
